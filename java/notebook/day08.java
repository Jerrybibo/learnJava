1:封装
	概述:隐藏对象的属性(变量)和实现细节(方法),仅仅对外提供公共的访问方式,封装是面向对象的三大特征之一,(继承,多态)
	如何隐藏:暂时通过private私有关键字来隐藏,私有仅仅在本类中被访问,注意,私有仅仅是封装的一种体现形式
	公共访问方式:get和set方法,都用public修饰,在哪里都可以被访问
	例子:理解,封装就是包装,比如你送充气娃娃给朋友,把礼物包装起来(隐藏对象属性和实现细节),解开礼物的绳子或者拉链(公共的访问方式)
	除了private私有,用默认修饰符也能封装,代码如下:前面什么都不写,默认修饰符,只有在同一个包下才能被访问,不同包下的类不能访问
	package mimi;
	//在mimi包下写了一个MiMi类
	public class MiMi {//前面什么都不写,默认修饰符,只有在同一个包下才能被访问(巧记默认同胞),不同包下的类不能访问
		double money = 6666666.0;//隐藏对象的属性和实现细节
		//仅仅对外提供公共的访问方式
		public double getMoney(){//public公有的,什么地方都可以访问
			return money;//返回值表示方法调用完毕得到的结果,返回,带回
		}

		public void setMoney(double money){
			this.money = money;
		}
		
		void show(){//隐藏对象的属性和实现细节
			System.out.println("show");
		}
		
		//仅仅对外提供公共的访问方式
		public void giveMoney(int i ){
			if (i>=500) {
				show();
			}else {
				System.out.println("钱太少了");
			}
		}
	}

	//test包下写了一个Test类
	package test;
	public class Test {
		public static void main(String[] args){
			MiMi mm = new MiMi();//对象名mm
			System.out.println(mm.money);//报错,因为money用什么都不写,默认修饰符修饰只能在被同一个包下的类访问
		}
	}

2:继承
	概述:我们发现很多类有很多共同的功能,我们就把这些功能抽取到另外一个类里面存起来,让其他类跟这个类发生关系,继承关系,
	用extends关键字来表示,这样其他类不用写也可以继承这个类里面的可以继承过来的东西

	格式://搞定
	public class Student extends Person{//让其他类跟这个类发生关系,继承关系,用extends关键字来表示
		//学生类继承人类,就可以用人类里面继承过来的东西,变量和方法,共同功能(除了父类的构造方法,非private修饰的东西都可以继承)
		//学生类,子类,派生类
		//人类,父类,超类,基类
	}
	
	//下面一大波,出去找工作的时候,面试可能问到,现在没时间,也可以到时候在背背记忆,但是重在理解记忆!!!
	类与类之间的继承关系://Java是很符合伦理道德的,搞定,继承就是亲生关系
		1.Java里面类与类之间只支持单继承(一个类只能同时继承一个类,一个儿子只能有一个亲爹),不支持多继承(一个类同时继承多个类)
		2.Java里面类与类之间支持多层(重)继承,比如A继承B,B继承C,A就间接继承C(子父爷)//搞定
		
	注意事项://搞定
		1.子类只能继承父类中非私有成员,包括成员变量和成员方法(父类中用private私有的东西子类不能访问,私有仅仅在本类(父类)中被访问,
		其他类不能访问,子类跟父类不是同一个类)

		2.子类不能继承父类中的构造方法,//留但是可以通过super关键字去访问,super,本类当前父类对象的引用(是子类中父类数据的一块存储空间)
		  //可以理解为存的是父类对象的地址值,
		  //通过父类对象的地址值是不是可以找到父类对象?就可以使用父类对象里面变量和方法,(比如super();表示调用访问父类的无参构造方法)

		3.不要为了部分功能而去使用继承//搞定
			什么时候使用继承?
			要有所属关系,is a 的关系,A is a B,A是B的一种,比如苹果是水果的一种,就可以使用继承,苹果是子类,水果是父类(谁是谁的一种)

	好处://搞定
		1.提高代码的复用性(少写了很多代码,实现一样的功能)
		2.让类与类之间发生关系,继承关系,这个关系是多态的前提条件

	弊端:类的耦合性加强了//面试,搞定
		开发中的原则:高内聚,低耦合,如果一个类能自己干的,就不要跟其他类发生过多的关系
		内聚:就是类自己独立完成某件事情的能力
		耦合:就是类与类之间的关系(万一其中一个类写坏了,其他类也坏了)
		
	//掌握下面这个,记忆,背背!!!搞定
	继承中的成员访问特点://当创建子类对象的时候,调用成员变量和成员方法有什么规律,遵循什么原则:就近原则
		成员变量:就近原则,子类有就使用子类的,否则使用父类的,如果最终父类都没有,就报错,谁靠近我,我就使用谁
		成员方法:就近原则,子类有就使用子类的,否则使用父类的,如果最终父类都没有,就报错,谁靠近我,我就使用谁//搞定

		构造方法:子类的构造方法默认会访问父类的无参的构造方法,因为子类的构造方法的第一行默认写的都是super();
		不写也是写,系统写,.//留下但是如果你写,系统不再提供,就按照你写的走,//搞定
		super();表示调用父类的无参的构造方法,为什么要这么做:
		因为创建子类对象的时候会调用到子类的构造方法,
		子类的构造方法默认会访问父类的无参的构造方法,我就可以在父类的构造方法里面给父类数据进行初始化(比如给父类的成员变量赋值)
	
	继承相关:
		方法重写://知道怎么写,怎么用就可以了,下面一大波也是出去面试可能问到,重在理解记忆:
			概述:子类中出现跟父类方法几乎一样的方法,子类的这个方法叫做父类方法的重写,覆盖,复写(能够继承拿到然后在子类重新写一遍)

			应用场景:子类想要沿袭(使用)父类的功能,又想有子类特有的功能,就要用到方法重写(为了让子类比父类更加强大)
			注意事项:
				1.父类的私有方法,子类不能重写(父类的私有方法只能在父类中访问,子类根本看不到,无法访问,更加无法继承,无法重写)
				2.子类重写方法的访问权限要大于或者等于父类(子类要比父类更加强大,强大到访问权限都比父类强大,不能比父类弱)
					访问权限从小到大排序:private(私有仅仅在本类中被访问)-默认什么都不写(默认可以在同一个包下被访问,巧记默认同胞)-
					protected(受保护的,只能给子类去访问不管是否同包)-public(公有在哪里都可以访问,公有秒杀)

				3.静态方法只能覆盖静态方法,从严格意义上讲这个不算方法重写,但是现象却是如此(多态再讲)
				  理解:方法重写最终调用到是子类的方法,只不过在子类方法里面调用到父类方法而已

		应用场景代码:
		public  void method(){//子类重写父类的方法,方法重写
			//super,本类当前父类对象的引用,存的是父类对象地址值,找到父类对象,就可以使用父类对象里面变量和方法
			super.method();//调用父类的method方法,传家宝
			System.out.println("学号Java月薪过万");
		}

		注意:如果父类方法是静态,子类也要是静态,应用场景代码如下:
		public static void method(){//重写,重新,子类能够继承拿到这个方法,然后在子类重写一遍
			//super.method();//报错,静态里面没有this和super,因为现在随着类的加载,类的加载优先于对象存在
			Fu.method();//既然父类方法是静态,就可以通过父类的类名点来调用
			System.out.println("学好Java月薪上万");
		}

		final关键字:最终的意思,最后一个的意思
		修饰的变量是最终变量(常量),只能被赋值一次

		修饰的方法是最终方法,最终方法不能被重写(最终方法表示最后一个方法,如果还能被重写,那么重写的那个就是最终方法,矛盾)
		修饰的类是最终类,最终类不能被继承(最终类就是最后一个类,如果还能被继承,那么继承的子类是最终类,矛盾)

3:抽象类//知道怎么写,怎么用就可以了,下面一大波也是出去面试可能问到,重在理解记忆://抽象类就记一句话不能创建对象所有方法子类实现使用!!!
	概述:有抽象方法的类一定是抽象类,抽象用abstract关键字表示,更准确的说用abstract修饰的类就是抽象类
	     抽象方法,没有方法体{},抽象方法也要用abstract修饰,抽象方法存在的意义:就是为了让子类强制去重写从而实现的事情

	特点://记忆,抽象类就记一句话不能创建对象所有方法由子类实现使用!!!
		1.有抽象方法的类一定是抽象类,抽象用abstract关键字表示//搞定

		2.不能通过抽象类的类名来直接创建抽象类对象(假如可以拿到对象调用抽象方法,没有方法体{}做不了事情,没有意义,不能创建对象),
			抽象类不能直接实例化(创建对象,实例)
			可以通过抽象类的子类来间接的创建对象,或者子类多态实例化//搞定

		3.抽象类的子类://搞定
			要么也是抽象类,但是没有意义(因为子类也是抽象类不能创建对象),所以不推荐使用
			要么是个普通类,你一定要重写抽象类里面 所有的 抽象方法

		4.抽象类也有构造方法(凡是类都有构造方法),既然有构造方法但是又不能通过构造方法来创建对象,
		  那么抽象类的构造方法存在的意义是什么:创建子类对象的时候会调用到子类的构造方法,但是子类的构造方法默认会调用父类的无参的
		  构造方法,你就可以在父类的构造方法里面给父类数据进行初始化(比如给父类的成员变量赋值,当然你还可以做其他事情)//搞定

	注意事项://面试问,到时候再记也可以记忆
		1.抽象类里面有没有非抽象方法?有
		  抽象方法跟非抽象方法的区别:
		  抽象方法:就是为了让子类强制去重写从而实现的事情
		  非抽象非私有方法:让子类去继承的事情,可以提高代码的复用性(少写了很多代码实现一样的功能)//搞定

		2.abstract,抽象的意思,这个关键字不能与哪里关键字共存:private,static,final
		  private:私有方法子类不能访问不能继承不能重写,而抽象方法就是为了让子类强制去重写从而实现的事情,设计上冲突
		  static:静态方法,可以通过类名.来调用,抽象方法没有方法体{},你用类名.去调用一个抽象方法没有意义,设计上冲突
		  final:最终方法不能被重写,而抽象方法就是为了让子类强制去重写从而实现的事情,设计上冲突//搞定

		3.抽象类一定有抽象方法吗?不一定,用abstract修饰的类就是抽象类
		  那么没有抽象方法的抽象类存在的意义:可以让子类去继承,提高代码的复用性
		  有抽象方法的抽象类有什么意义:抽象方法没有方法体{},也就是未实现的方法,就是为了让子类强制去重写从而实现的事情
		
4:接口//知道怎么写,怎么用就可以了,下面一大波也是出去面试可能问到,重在理解记忆:
	概述:从广义上讲接口就是对外提供的规则,比如USB接口,从狭义上在Java里面指的是用interface(接口)修饰的东西

	特点://类比,类,推出来//记忆
		1.用interface关键字去表示接口(class表示类)
		2.类与接口是实现关系,用implements(实现)关键字来表示(继承就是亲生,实现就是干儿子,实现类似于继承)(类与类继承关系extends)
		3.接口也不能直接通过new接口名来创建对象,接口不能直接实例化
			可以使用接口的实现类(干儿子类)来创建对象,接口多态实例化

		4.接口的实现类(就是接口的干儿子类):
			要么也是抽象类,但是没有意义(因为实现类也是抽象类不能创建对象),所以不推荐使用
			要么是个普通类,你一定要重写接口里面 所有的 抽象方法//搞定
			
	类与接口之间的关系://巧记,如果是同类就认为有血缘关系,有血缘关系的就是亲生的用继承,没有血缘关系的不是亲生的用实现,即干的关系
		类与类:继承关系,只能单继承,不能多继承(一个儿子只能有一个亲爹),但是可以多层(重)的继承(子父爷)

		类与接口:实现关系,可以单实现,也可以多实现,甚至可以在继承一个类的同时实现多个接口(这种情况要先继承再实现,先有亲爹再有干爹)

		接口与接口:继承关系,可以单继承,也可以多继承,接口的出现打破类的单继承的局限性//搞定

	成员特点:
		JDK1.7及其以前:接口里面都是常量和抽象方法(可以写可以不写)
		常量:默认修饰符,不写也是写,系统给你写:public static final

		抽象方法:默认修饰符:不写也是写,系统给你写:public abstract

		JDK1.8有新特性:接口可以有非抽象方法,如果是静态方法直接写,如果是非静态方法要加上default关键字去修饰,知道一下就好//搞定

	注意事项:接口不是类,没有构造方法(凡是类都有构造方法),但是可以把接口当做类来看待,理解//搞定

	抽象类跟接口的区别://搞定
		抽象类是个类,就有构造方法,既然是个类,如果继承某个类,就不能继承其他类,Java里面类只支持单继承
		接口不是类,没有构造方法,接口可以多继承也可以多实现,接口的出现打破类的单继承的局限性
		抽象类定义共性功能,先天就有的
		接口定义扩展功能,要经过后天培训的

5:多态//知道怎么写,怎么用就可以了,下面一大波也是出去面试可能问到,重在理解记忆:
	概述:同一种事物在不同时刻的不同状态,比如H20可以变成水,水蒸气,冰
	前提条件://记忆
		1.要有继承关系(实现关系)//引用:引用数据类型的变量,类,类型,引用数据类型
		2.要有父类引用f指向=子类对象(父接口引用指向实现类对象)//Fu f = new Zi();(最重要的是这个条件,你甚至可以错误认为这个就是多态)
		3.要有方法重写

	成员访问特点://巧记只有父类引用调用非静态方法,编译看左边,运行看右边,其他的都看左边(父类里面的)
		满足多态的前提条件的时候,用父类引用去调用成员变量和成员方法的时候,遵循什么规则,规律://要记忆
		规则规律:记忆:用父类引用去调用非静态方法的时候,编译看左边父类里面,没有就报错,运行的结果看右边的子类里面的方法(动态绑定)
		         其他情况下,不管编译和运行都看左边父类里面的东西//多态规律,要重点掌握,记忆,应用!!!
	
	好处:提高代码的维护性,提高代码的扩展性//多态应用,重要掌握,要学会这么写方法,记忆!!!
		 体现在多态在开发中应用:写一个方法的时候,方法的形式参数可以写父类类型引用,就可以指向所有的子类对象,
		 换句话,父类引用可以接收所有的子类对象
		 代码如下:
		 //能不能写一个方法实现上面两个方法的功能
		 public static void diaoyong(Fu f){//f = z4;z4 = new Zi3();/ Fu f= new Zi3();//父类引用指向子类对象,多态前提条件
			 f.method();//写父类类型引用,就可以指向所有的子类对象,换句话,父类引用可以接收所有子类对象
			 //用父类引用去调用 非静态方法 的时候,编译看左边父类里面,没有就报错,运行的结果看右边的子类里面的方法
		 }

	弊端:父类引用(对象)不能直接使用调用子类对象里面的特有功能(父类没有,子类有,特有,包括成员变量和成员方法)
	     如果我一定要使用怎么办?就要用到向下转型:
		 向上转型:父类引用指向子类对象,Fu f = new Zi();//父类高高在上

		 向下转型,把父类引用强转为子类对象(引用):代码如下
		 Fu f = new Zi();
		 Zi z = (Zi) f;//向下转型,把父类引用强转为子类对象(引用),//Fu f = new Zi();Zi z = (Zi) f;//Zi z = (Zi) new Zi();
		 System.out.println(z.i);
		 //这样做太麻烦,还不如直接创建子类对象来调用,那么多态的好处到底体现在哪里呢?

	多态最重要的规律://巧记只有父类引用调用非静态方法,编译看左边,运行看右边,其他的都看左边(父类里面的)
		 父类引用指向子类对象的时候,用一个父类引用去调用一个非静态方法的时候,编译看左边的父类的方法,没有报错,
		 运行结果看右边子类里面的方法(动态绑定),其他情况不管编译还是运行都看左边父类里面东西,包括变量和方法!!

		 多态://就记这句话多态就懂就会用了!!!
		 当父类引用指向子类对象的时候,用父类引用调用非静态方法编译看左边父类,运行的结果看右边子类,其他情况不管编译运行都看左边父类

6:黑马GUI游戏引擎,GUI就是图形用户接口,用来画图的,这个东西已经淘汰了,你就不用专门学习它里面的类和类里面的特定方法,api
	目的:学习如何使用jar包,就是学习如何使用别人写好的类
	jar包:打开由很多.class结尾的字节码文件,对应就是我们写的类编译后得到的结果,运行的时候,运行的正是这些字节码文件

7.微信打飞机开发//注意的jar包要求这里要用到jdk1.8的eclipse才行,用我发的文件夹里面的那个,名字叫Eclipse1.8.zip,解压,运行!!!
	1.新建Java项目,选择你的项目鼠标右键-新建文件夹名字叫libs,把需要的jar包拷贝到这个文件夹下-展开文件夹选中jar包鼠标右键-
	  构建路径-添加到构建路径-看到一个小奶瓶就拷贝jar包到eclipse成功

	2.新建一个测试类带有main方法,程序入口

	3.写一个游戏窗体类去继承我们jar包里面一个类叫黑马抽象世界类,去继承这个类的start方法才能去开启一个游戏窗体

	4.把需要的图片拷贝到src文件夹下面新建的文件夹images里面

8:常见面向对象案例分析
	有时间的话完成下面的作业:
	案例一:
		已知有猫类和狗类,他们都有姓名和年龄
		也都有吃饭的方法,不同的是猫吃鱼,狗吃肉
		也都会跑步,而且仅仅是跑步
		请用继承的思想,设计出类,并测试
		
	案例二:
		上午讲的老师和学生类案例,用继承的思想重新练习下
	
	案例三:
		如果有时间的话,可以用继承的思想,优化下咱们讲的:黑马RPG游戏(通过玩家类和电脑人类,抽取一个父类出来)
		
	案例四:
		员工类案例:
			已知某公司有项目经理和程序员两个职位,
				项目经理:
					属性:
						姓名
						工号
						工资
						奖金
					行为:
						工作
						喝茶
				程序员:
					属性:
						姓名
						工号
						工资
					行为:
						工作
		请用继承的思想完成该案例.

9:补充内容


	

